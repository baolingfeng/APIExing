pandas iloc vs ix vs loc explanation ?
Can someone explain how these three methods of slicing are different ?
I've seen the docs ,
and I've seen these answers , but I still find myself unable to explain how the three are different . To me , they seem interchangeable in large part , because they are at the lower levels of slicing .
For example , say we want to get the first five rows of a ` DataFrame ` . How is it that all three of these work ?
Can someone present three cases where the distinction in uses are clearer ?
very important to mention the SettingWithCopyWarning scenarios : stackoverflow.com/questions/20625582 and stackoverflow.com/questions/23688307
Note that ix is now planned for deprecation : github.com/pandas-dev/pandas/issues/14218
Note : in pandas version 0.20.0 and above , ` ix ` is deprecated and the use of ` loc ` and ` iloc ` is encouraged instead . I have left the parts of this answer that describe ` ix ` intact as a reference for users of earlier versions of pandas . Examples have been added below showing alternatives to ` ix ` .
First , a recap :
` loc ` works on labels in the index .
` iloc ` works on the positions in the index ( so it only takes integers ) .
` ix ` usually tries to behave like ` loc ` but falls back to behaving like ` iloc ` if the label is not in the index .
It's important to note some subtleties that can make ` ix ` slightly tricky to use :
if the index is of integer type , ` ix ` will only use label-based indexing and not fall back to position-based indexing . If the label is not in the index , an error is raised .
if the index does not contain only integers , then given an integer , ` ix ` will immediately use position-based indexing rather than label-based indexing . If however ` ix ` is given another type ( e.g. a string ) , it can use label-based indexing .
To illustrate the differences between the three methods , consider the following Series :
Then ` s.iloc [: 3 ]` returns the first 3 rows ( since it looks at the position ) and ` s.loc [: 3 ]` returns the first 8 rows ( since it looks at the labels ):
Notice ` s.ix [: 3 ]` returns the same Series as ` s.loc [: 3 ]` since it looks for the label first rather than going by position ( and the index is of integer type ) .
What if we try with an integer label that isn't in the index ( say ` 6 `) ?
Here ` s.iloc [: 6 ]` returns the first 6 rows of the Series as expected . However , ` s.loc [: 6 ]` raises a KeyError since ` 6 ` is not in the index .
As per the subtleties noted above , ` s.ix [: 6 ]` now raises a KeyError because it tries to work like ` loc ` but can't find a ` 6 ` in the index . Because our index is of integer type it doesn't fall back to behaving like ` iloc ` .
If , however , our index was of mixed type , given an integer ` ix ` would behave like ` iloc ` immediately instead of raising a KeyError :
Keep in mind that ` ix ` can still accept non-integers and behave like ` loc ` :
As general advice , if you're only indexing using labels , or only indexing using integer positions , stick with ` loc ` or ` iloc ` to avoid unexpected results - try not use ` ix ` .
Combining position-based and label-based indexing
Sometimes given a DataFrame , you will want to mix label and positional indexing methods for the rows and columns .
For example , consider the following DataFrame . How best to slice the rows up to and including ' c ' and take the first four columns ?
In earlier versions of pandas ( before 0.20.0 ) ` ix ` lets you do this quite neatly - we can slice the rows by label and the columns by position ( note that for the columns , ` ix ` default to position-based slicing since the label ` 4 ` is not a column name ):
In later versions of pandas , we can achieve this result using ` iloc ` and the help of another method :
` get_loc() ` is an index method meaning " get the position of the label in this index " . Note that since slicing with ` iloc ` is exclusive of its endpoint , we must add 1 to this value if we want row ' c ' as well .
There are further examples in pandas ' documentation here .
This is the kind of example that would be SO helpful in the docs .
Great explanation ! One related question I've always had is what relation , if any , loc , iloc and ix have with SettingWithCopy warnings ? There is some documentation but to be honest I'm still a little confused pandas.pydata.org/pandas-docs/stable
@USER : ` loc ` , ` iloc ` and ` ix ` might still trigger the warning if they are chained together . Using the example DataFrame in the linked docs ` dfmi.loc [: , ' one '] .loc [: , ' second ']` triggers the warning just like ` dfmi [ ' one '] [ ' second ']` because a copy of data ( rather than a view ) might be returned by the first indexing operation .
I think the last example is not fully correct , because in ` df.ix [ 1:3 , : ' b ']` both are label-based . BTW , always welcome to improve the docs to make things more clear !
Thanks @USER - I've updated / corrected the example . I'd definitely be happy to have a look at the docs sometime to see if there's anything I can contribute ...
` iloc ` works based on integer positioning . So no matter what your row labels are , you can always , e.g. , get the first row by doing
or the last five rows by doing
You can also use it on the columns . This retrieves the 3rd column :
You can combine them to get intersections of rows and columns :
On the other hand , ` .loc ` use named indices . Let's set up a data frame with strings as row and column labels :
Then we can get the first row by
and the second two rows of the `' date '` column by
and so on . Now , it's probably worth pointing out that the default row and column indices for a ` DataFrame ` are integers from 0 and in this case ` iloc ` and ` loc ` would work in the same way . This is why your three examples are equivalent . If you had a non-numeric index such as strings or datetimes , ` df.loc [: 5 ]` would raise an error .
Also , you can do column retrieval just by using the data frame's ` __getitem__ ` :
Now suppose you want to mix position and named indexing , that is , indexing using names on rows and positions on columns ( to clarify , I mean select from our data frame , rather than creating a data frame with strings in the row index and integers in the column index ) . This is where ` .ix ` comes in :
EDIT :
I think it's also worth mentioning that you can pass boolean vectors to the ` loc ` method as well . For example :
Will return the 1st and 3rd rows of ` df ` . This is equivalent to ` df [ b ]` for selection , but it can also be used for assigning via boolean vectors :
Is df.iloc [: , :] equivalent to all rows and columns ?
It is , as would be ` df.loc [: , :] ` . It can be used to re-assign the values of the entire ` DataFrame ` or create a view of it .